The **Zen of Python** is a collection of 19 aphorisms, which reflect the philosophy behind Python, its guiding principles, and design.

Tim Peters, a long time major contributor to the Python programming language and Python community, wrote this 19-line poem on the Python mailing list in 1999, and it became [entry #20](https://www.python.org/dev/peps/pep-0020/) in the Python Enhancement Proposals in 2004.

It’s one of the _Easter eggs_ (i.e., hidden, secret messages or features) included in the Python interpreter.

Now let’s see the magic. Go to the editor window, type in `import this`, run the code, and voilà! Can you see what happens?

  
![The Zen of Python](https://edube.org/uploads/media/default/0001/02/edd10b906771293506182dad9c1285f904410700.png)  
  

What you see is a collection of some general truths for Python design rules and decision making. Even though the "poem" seems to be imbued with contradictions and allusions, we assure you that the aphorisms are extremely practical and common sense, and you’re encouraged to accept them and implement in your code.

These, of course, should be looked upon holistically, rather than individually, but, still, let’s try to meditate on each of them.

# Beautiful is better than ugly

Beauty is a rather subjective experience. But, as Immanuel Kant said, the very **esthetic experience of beauty is a judgement of human truth**.

And even though the computer doesn’t care about beauty or esthetics, people do, and we must remember that a nicely-written program is not only more enjoyable to read, but also more **readable**.

Python has certain **style rules** that programmers are recommended to follow. These are, among other things: a 79-character maximum line length, variable naming conventions, placing statements on separate lines, and many others.

![Beautiful is better than ugly](https://edube.org/uploads/media/default/0001/02/c3ca6356713b64df8639f02c0a0dde5b9c8d4f87.png)  
  
Example: Write a program that calculates the hypotenuse of a right-angled triangle.
# $\color{red}\times$
```python
from math import sqrt

sidea = float(input("The length of the 'a' side:"))
sideb = float(input("The length of the 'b' side:"))

sidec = sqrt(a**2+b**2)

print("The length of the hypotenuse is", sidec)
```
# $\color{green}\checkmark$
```python
from math import sqrt
side_a = float(input("The length of the 'a' side: "))
side_b = float(input("The length of the 'b' side: "))

hypotenuse = sqrt(a**2 + b**2)

print("The length of the hypotenuse is", hypotenuse)
```

# Explicit is better than implicit

The code you write should be **explicit and readable**.

Whenever you want to use an implicit feature of the language, ask yourself whether you really need it. Maybe there’s a better way to implement the functionality. If not, think about leaving a comment in code to explain what’s going on so that other programmers find it easier to understand your code.

In Python, it’s preferred to use not only the simplest way to express a programming idea, but also the most explicit, concrete, specific one.

![Explicit is better than implicit](https://edube.org/uploads/media/default/0001/02/19d1da968e377dcc1c8907c73bb93fc71bc4e67e.png)

Therefore, it’s sometimes a good idea to add more verbosity to your code as it all counts towards readability. Giving self-explanatory variable and function names, or adding more explicitness to imports or function arguments may be good practice.

Example: Import `apples` and `bananas` from the _fruit.py_ module.

# $\color{red}\times$
```python
from fruit import *

apples(2, 3.45)

```
# $\color{green}\checkmark$
```python

from fruit import apples, bananas

apples(quantity=2, price=3.45)
```

# Simple is better than complex

Simplicity is the key to success.

A **simpler solution** is usually preferred over a complex one, and generally, the minimalistic approach wins. Remember: use appropriate **tools adjusted to the specificity** of your project.

Using a plane to transport yourself to a nearby shop could be okay (assuming you’re slightly eccentric), but usually it’d be enough to walk or drive. Similarly, you wouldn’t normally walk the distance if you wanted to travel from the UK to the USA. Taking a plane would be a more sensible idea here.

Consider not adopting an object-oriented approach when it’s not needed. Use fewer lines of code if that’s possible.

![Simple is better than complex](https://edube.org/uploads/media/default/0001/02/dd920afb4e53b7ec612f6d182e33b8ba88331f62.png)

If you need to implement a more complex solution, **divide problems into smaller, simpler parts**.

Example: Sort the `numbers` list in ascending order.
# $\color{red}\times$
```python 
import heapq

numbers = [-1, 12, -5, 0, 7, 21, 15, 1]
heapq.heapify(numbers)
sorted_numbers = []

while numbers:
	sorted_numbers.append(heapq.heappop(numbers))

print(sorted_numbers)
```
# $\color{green}\checkmark$
```python
numbers = [-1, 12, -5, 0, 7, 21, 15, 1]
numbers.sort()
print(numbers)
```

# Complex is better than complicated

When simple solutions are not possible, be aware of the **limitations carried by simplicity**, and use complex solutions instead.

Distinguishing between _complex_ as _consisting of many elements_ and _complicated_, meaning _difficult to understand_, is yet another thing to consider when writing code.

In other words, there are times when a complex solution may be preferred over a simple one, especially in the case of the latter causing misunderstanding, doubt, or misinterpretation. You should avoid those.

On the other hand, complex is always preferred to complicated. When your code gets big and too difficult to understand and grasp, **divide it into well-separated parts**, so that it’s easier to manage and handle.

![Complex is better than complicated](https://edube.org/uploads/media/default/0001/02/c0b409025760be490dcc87d94369c9b8e8d907a3.png)

**Avoid misunderstanding, lack of clarity, and miscomprehension**.

Example: Perform five additions of two numbers.
# $\color{red}\times$
```python
first_number = int(input("Enter the first number: "))

second_number = int(input("Enter the second number: "))

addition_result = first_number + second_number

print(first_number, "+", second_number, "=", addition_result)

first_number = int(input("Enter the first number: "))

second_number = int(input("Enter the second number: "))

addition_result = first_number + second_number

print(first_number, "+", second_number, "=", addition_result)

first_number = int(input("Enter the first number: "))

second_number = int(input("Enter the second number: "))

addition_result = first_number + second_number

print(first_number, "+", second_number, "=", addition_result)

first_number = int(input("Enter the first number: "))

second_number = int(input("Enter the second number: "))

addition_result = first_number + second_number

print(first_number, "+", second_number, "=", addition_result)

first_number = int(input("Enter the first number: "))

second_number = int(input("Enter the second number: "))

addition_result = first_number + second_number

print(first_number, "+", second_number, "=", addition_result)
```
# $\color{green}\checkmark$
```python
def addition(x, y):
	print(x, "+", y, "=", x+y)

for i in range(5):
	first_number = int(input("Enter the first number: "))
	second_number = int(input("Enter the second number: "))
	addition(first_number, second_number)
```

# Flat is better than nested

**Nesting code makes it more difficult to follow and understand**. Nesting two or three levels deep may still be good, but anything beyond that becomes confusing and unreadable.

Even though you can actually have any level of nested loops or if statements in Python, **anything above three** should be a clear signal that it’s maybe a good time to start refactoring your code.

![Flat is better than nested](https://edube.org/uploads/media/default/0001/02/5ec3464b668d22fb452881e9a3021213f9c5b2d4.png)

Flat code is more user-friendly, and becomes much **easier to maintain**. Remember this.

Example: Display a message whether or not x is within the range from 4 to 6.
# $\color{red}\times$
```python
x = float(input("Enter a number: "))

if x > 0:
	if x > 1:
		if x > 2:
			if x > 3:
				if x >= 4:
					if x <= 6:
						print("x is a number between 4 and 6.")

else:
	print("x is not a number between 4 and 6.")
```
# $\color{green}\checkmark$
```python
x = float(input("Enter a number: "))

if x >= 4 and x <=6:
	print("x is a number between 4 and 6.")
else:
	print("x is not a number between 4 and 6.")
```

# Sparse is better than dense

Don’t write too much code in one line, don’t fit too much information into a small amount of code, don’t write lines of code that are too long, use whitespaces responsibly – this all affects the readability and understanding of your program.

The easiest and most common way to introduce sparsity to your code is to introduce nesting. That’s probably why this aphorism comes right after the one which tells us to prefer flat code over nested code. The key to readability is to strike a balance between the two: **reduce nesting**, then try to **reduce density**.

![Sparse is better than dense](https://edube.org/uploads/media/default/0001/02/78a633d719ecce08aefb25d1feed9d01f8236db4.png)

Example: Print the message “Hello, World!” if the value passed to the x variable equals 1.
# $\color{red}\times$
```python
x = 1

if x == 1 : print("Hello, World!")
```
# $\color{green}\checkmark$
```python
x = 1

if x == 1:
	print("Hello, World!")
```

# Readability counts

Your code is not only read by computers, it’s also (or most of all) read by humans. In fact, it’s **the essence of the Python philosophy**, and the whole of Python design and culture actually revolves around the very statement that **“code is read more often than it is written”** (Guido Van Rossum).

All the previous aphorisms (and the subsequent ones) pave the way to readability, to a lesser or greater extent, as one of the most crucial factors that should be kept in mind while creating code. Whenever you feel tempted to give up on readability, the reason be it saving time by having to think up meaningful names, the effort taken to format your code, or any other reason – reject the temptation. Don’t underestimate the power of readability, especially when you have to return to your code after some time, or leave the code for others to develop in the future.

Giving **meaningful names** to variables, functions, modules, and classes; properly **styling blocks of code**; **using comments** where necessary; keeping your code neat and elegant – these all contribute to how readable and user-friendly your code is.

![Sparse is better than dense](https://edube.org/uploads/media/default/0001/02/3b832ffa06c8326e0f702d4d30cf22f6ed315c0a.png)

Remember: the readability of your code reflects how responsible a programmer you are. It not only reflects well on the quality of the code, it reflects well on its author.

Example: Write a program that calculates a product’s gross price.
# $\color{red}\times$
```python
def f(i):
	l = i + (0.08 * i)
	return l
```
# $\color{green}\checkmark$
```python
# Calculates the gross price of products in Wonderland.`

def calculate_gross_price(net_price):
	gross_price = net_price + (0.08 * net_price)
	return gross_price
```

# Special cases aren't special enough to break the rules...

**Discipline, consistency, and compliance with standards and conventions** are all important elements in professional and responsible code development. There should be no exceptions that allow us to break the principles governing best coding practices.

No special cases such as time pressure or complexity of a given problem should be an excuse for writing code that does not follow the guidelines.

It’s not only about readability, though it should be one of the first things you think about, but it’s also about sticking to the design and development-related decisions you’ve made, be it consistency which can **ensure backward compatibility**, keeping naming conventions unchanged, or anything else.

![Special cases aren't special enough to break the rules...](https://edube.org/uploads/media/default/0001/02/b6aa7d2c8f673f666120d3eb3c8c2fd37cb39fea.png)

Example: Write a function that multiplies two numbers and a function that adds two numbers.
# $\color{red}\times$
```python
def multiply_two_numbers(first_number, second_number):
	return first_number * second_number

print(multiply_two_numbers(7, 9))

def addingTwoNumbers(firstNumber, secondNumber):
	return firstNumber + secondNumber

print(addingTwoNumbers(7, 9))
```
# $\color{green}\checkmark$
```python
def multiply_two_numbers(first_number, second_number):
	return first_number * second_number

print(multiply_two_numbers(7, 9))

def add_two_numbers(first_number, second_number):
	return first_number + second_number

print(add_two_numbers(7, 9))
```

# ...Although, practicality beats purity

Okay… what’s going on here? The previous aphorism encouraged us to never break the rules, while this one says there might be some exceptions to this. Why?

![...Although, practicality beats purity](https://edube.org/uploads/media/default/0001/02/3c4b7ef9b1e5a14acdf88e8b0c4f4ec7890fa003.png)

Well, we must remember that the ultimate goal is to solve real problems and write code that performs some particular (expected) task. If your code is elegant, readable, and complies with all the important styling conventions, but does not function the way it should, then it doesn’t make much sense, does it?

If the possible benefits (e.g., better performance) are larger than the possible negative effects (e.g., affected maintainability), the real-world coding problems may find an excuse for making an exception to the rules. Practicality then becomes more important than purity.

If you need to write an 85-character long line of code because splitting it into two separate lines affects readability, do it. If you need to keep compatibility with previously written code and use CamelCase instead of snake_case, do it. Rules sometimes have to be broken, exceptions have to be made.

